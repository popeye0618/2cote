#A -> B(실버 2)
#내 풀이
#우선 거꾸로 가는 방식이 더 편할 것 같고, 1을 떼는 것이 2로 나누는 것 보다 반드시 값이 작아진다.
#따라서 B가 A보다 클 때 끝 자리가 1이라면 1을 떼고, 아니라면 2로 나누어 간다.
#최종적으로 A가 나오면 횟수 출력, A보다 작아지면 -1을 출력한다.

#피드백
#1을 붙일 타이밍을 정방향으로 가면 절대 모를 것 같고 무조건 거꾸로 가는 방식으로 가는게 맞는 것 같다.
#틀린 이유는 -1이 나오는 경우가 추가되어야 함(만들어야 할 수가 1로 끝나지 않는 홀수인 경우는 만들 수 없다.)

a, b = map(int, input().split())
cnt = 1

while True:
  if b == a:
    print(cnt)
    break
  if (b < a) or (b % 10 != 1 and b % 2 != 0):
    print(-1)
    break
    
  if b % 10 == 1:
    b //= 10
    cnt += 1
  else:
    b //= 2
    cnt += 1